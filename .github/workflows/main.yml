name: CI/CD — App Service (docker-compose, SP secret)

on:
  push: { branches: [ "main" ] }
  workflow_dispatch:

permissions:
  contents: read

env:
  ACR_NAME:        ${{ vars.ACR_NAME }}
  REGISTRY:        ${{ vars.ACR_NAME }}.azurecr.io
  RESOURCE_GROUP:  ${{ vars.AZ_RESOURCE_GROUP }}
  WEBAPP_NAME:     ${{ vars.AZ_WEBAPP_NAME }}
  COMPOSE_FILE:    docker-compose.yml
  IMAGE_TAG:       ${{ github.sha }}
  PRIVATE_SERVICES: "mqtt-kafka-bridge kafka-redis-consumer edge"

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      images: ${{ steps.images.outputs.list }}
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (service principal secret)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - uses: docker/setup-buildx-action@v3

      - name: Login no ACR
        run: az acr login -n "$ACR_NAME"

      - name: Build & Push (somente serviços privados que existirem no compose)
        shell: bash
        run: |
          set -euo pipefail
          export REGISTRY="${{ env.REGISTRY }}"
          export IMAGE_TAG="${{ env.IMAGE_TAG }}"
          PRESENT=$(docker compose -f "${COMPOSE_FILE}" config --services)
          for s in $PRIVATE_SERVICES; do
            if echo "$PRESENT" | grep -qx "$s"; then
              echo ">> build/push: $s"
              docker compose -f "${COMPOSE_FILE}" build "$s"
              docker compose -f "${COMPOSE_FILE}" push  "$s"
            else
              echo ">> skip: $s (não está no compose)"
            fi
          done

      - name: Resolver imagens do compose (expand env)
        id: images
        shell: bash
        run: |
          set -euo pipefail
          export REGISTRY="${{ env.REGISTRY }}"
          export IMAGE_TAG="${{ env.IMAGE_TAG }}"
          docker compose -f "${COMPOSE_FILE}" config \
            | awk '/image:/ {print $2}' \
            | tr -d "\"'" > images.txt

          echo "list<<EOF" >> $GITHUB_OUTPUT
          cat images.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "==== Imagens detectadas ===="
          cat images.txt

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (service principal secret)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # Opcional porém recomendado: garante MI + AcrPull (idempotente)
      - name: Garantir Managed Identity + AcrPull no ACR
        shell: bash
        run: |
          set -euo pipefail
          az webapp identity assign -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" >/dev/null
          APP_MI=$(az webapp show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --query identity.principalId -o tsv)
          ACR_ID=$(az acr show -n "$ACR_NAME" --query id -o tsv)
          # Pode falhar se já existir — tudo bem
          az role assignment create \
            --assignee-object-id "$APP_MI" \
            --assignee-principal-type ServicePrincipal \
            --role "AcrPull" \
            --scope "$ACR_ID" || true

      # Define WEBSITES_PORT=80 para multi-container no App Service
      - name: App Settings essenciais
        shell: bash
        run: |
          az webapp config appsettings set -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" \
            --settings WEBSITES_PORT=80 >/dev/null

      - name: Deploy docker-compose ao App Service
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.WEBAPP_NAME }}
          configuration-file: ./${{ env.COMPOSE_FILE }}
          images: ${{ needs.build-and-push.outputs.images }}

      # Sonda /healthz até 200 (timeout ~2min)
      - name: Verificar saúde pós-deploy (/healthz)
        shell: bash
        run: |
          set -euo pipefail
          HOST=$(az webapp show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --query defaultHostName -o tsv)
          echo "Verificando https://$HOST/healthz"
          for i in {1..24}; do
            CODE=$(curl -sk -o /dev/null -w "%{http_code}" "https://$HOST/healthz" || true)
            if [ "$CODE" = "200" ]; then
              echo "OK: $CODE"
              exit 0
            fi
            echo "Aguardando... (status=$CODE)"
            sleep 5
          done
          echo "Falha: healthcheck não respondeu 200 no tempo esperado."
          exit 1
