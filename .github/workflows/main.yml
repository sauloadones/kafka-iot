name: CI/CD — App Service (docker-compose + Managed Identity)

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read

env:
  # Vars do ambiente
  ACR_NAME:        ${{ vars.ACR_NAME }}              # ex.: iotkafka
  REGISTRY:        ${{ vars.ACR_NAME }}.azurecr.io   # ex.: iotkafka.azurecr.io
  RESOURCE_GROUP:  ${{ vars.AZ_RESOURCE_GROUP }}     # ex.: iotstack-esus2-rg
  WEBAPP_NAME:     ${{ vars.AZ_WEBAPP_NAME }}        # ex.: iotkafka
  IMAGE_TAG:       ${{ github.sha }}

  # Caminhos
  COMPOSE_TEMPLATE: docker-compose.azure.yml      # template com ${REGISTRY}/${IMAGE_TAG}
  COMPOSE_RENDERED: docker-compose.final.yml

  # Serviços privados do seu ACR
  PRIVATE_SERVICES: "edge mqtt-kafka-bridge kafka-redis-consumer"

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.out.outputs.tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (SP)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - uses: docker/setup-buildx-action@v3

      - name: Login no ACR
        run: az acr login -n "$ACR_NAME"

      - name: Build & push (edge, mqtt-bridge, kafka-consumer)
        shell: bash
        run: |
          set -euo pipefail
          REGISTRY="${{ env.REGISTRY }}"
          TAG="${{ env.IMAGE_TAG }}"

          # mapeie os diretórios reais do seu repo:
          declare -A CTX=(
            ["edge"]="ops/edge"
            ["mqtt-kafka-bridge"]="python-bridge"
            ["kafka-redis-consumer"]="kafka-redis-consumer"
          )

          for s in ${{ env.PRIVATE_SERVICES }}; do
            [ -d "${CTX[$s]}" ] || { echo "::error::Diretório '${CTX[$s]}' não existe"; exit 1; }
            echo ">> buildx $s  →  $REGISTRY/$s:$TAG  (ctx=${CTX[$s]})"
            docker buildx build --platform linux/amd64 \
              -t "$REGISTRY/$s:$TAG" \
              --push "${CTX[$s]}"
          done

      - name: Verificar tags no ACR
        shell: bash
        run: |
          set -euo pipefail
          TAG="${{ env.IMAGE_TAG }}"
          for r in edge mqtt-kafka-bridge kafka-redis-consumer; do
            az acr repository show-tags -n "$ACR_NAME" --repository "$r" \
              --query "[?@=='$TAG']" -o tsv | grep -q . || { echo "::error::Tag '$TAG' ausente no repo '$r'"; exit 1; }
          done

      - name: Emitir tag
        id: out
        run: echo "tag=${{ env.IMAGE_TAG }}" >> "$GITHUB_OUTPUT"

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (SP)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Ativar Managed Identity (se ainda não) e dar AcrPull
        shell: bash
        run: |
          set -euo pipefail
          # garante MI
          az webapp identity assign -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" >/dev/null 2>&1 || true
          MI=$(az webapp show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --query identity.principalId -o tsv)
          ACR_ID=$(az acr show -n "$ACR_NAME" --query id -o tsv)
          az role assignment create --assignee-object-id "$MI" --assignee-principal-type ServicePrincipal \
            --role AcrPull --scope "$ACR_ID" >/dev/null 2>&1 || true
          az webapp update -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --set siteConfig.acrUseManagedIdentityCreds=true

      - name: Remover quaisquer DOCKER_* antigos (evita credenciais vazias)
        shell: bash
        run: |
          az webapp config appsettings delete -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" \
            --setting-names DOCKER_REGISTRY_SERVER_URL DOCKER_REGISTRY_SERVER_USERNAME DOCKER_REGISTRY_SERVER_PASSWORD || true

      - name: App Settings essenciais (porta/health/start/storage)
        shell: bash
        run: |
          az webapp config appsettings set -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --settings \
            WEBSITES_PORT=80 WEBSITES_HEALTHCHECK_PATH=/healthz \
            WEBSITES_CONTAINER_START_TIME_LIMIT=600 \
            WEBSITES_ENABLE_APP_SERVICE_STORAGE=true >/dev/null
          az webapp update -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" \
            --set siteConfig.alwaysOn=true siteConfig.healthCheckPath="/healthz" >/dev/null

      - name: Instalar envsubst
        run: sudo apt-get update && sudo apt-get install -y gettext-base

      - name: Renderizar docker-compose (REGISTRY/IMAGE_TAG)
        shell: bash
        run: |
          set -euo pipefail
          export REGISTRY="${{ env.REGISTRY }}"
          export IMAGE_TAG="${{ needs.build-and-push.outputs.tag }}"
          [ -f "${{ env.COMPOSE_TEMPLATE }}" ] || { echo "::error::Template não encontrado: ${{ env.COMPOSE_TEMPLATE }}"; exit 1; }
          envsubst < "${{ env.COMPOSE_TEMPLATE }}" > "${{ env.COMPOSE_RENDERED }}"
          echo "==== docker-compose.final.yml ===="
          cat "${{ env.COMPOSE_RENDERED }}"

      - name: Aplicar compose no App Service (CLI)
        shell: bash
        run: |
          set -euo pipefail
          az webapp config container set -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" \
            --multicontainer-config-type COMPOSE \
            --multicontainer-config-file "${{ env.COMPOSE_RENDERED }}"
          az webapp show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" \
            --query siteConfig.linuxFxVersion -o tsv

      - name: Restart
        run: az webapp restart -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME"

      - name: Health-gate /healthz (até 10 min)
        shell: bash
        run: |
          set -euo pipefail
          HOST=$(az webapp show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --query defaultHostName -o tsv)
          echo "Verificando https://$HOST/healthz"
          for i in {1..120}; do
            CODE=$(curl -sk -o /dev/null -w "%{http_code}" "https://$HOST/healthz" || true)
            if [[ "$CODE" =~ ^20[0-9]$ || "$CODE" =~ ^30[0-9]$ ]]; then
              echo "HEALTH OK ($CODE)"; exit 0
            fi
            echo "Aguardando... ($CODE)"; sleep 5
          done
          echo "Falha: /healthz não respondeu 2xx/3xx."; exit 1

      # (Opcional) Paraquedas: trocar health para "/" e mostrar cabeçalho, sem falhar o job
      - name: Fallback temporário de health (/) se falhar
        if: failure()
        shell: bash
        run: |
          set -euo pipefail
          az webapp update -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --set siteConfig.healthCheckPath="/"
          sleep 10
          HOST=$(az webapp show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --query defaultHostName -o tsv)
          curl -skI "https://$HOST/" || true
