name: CI/CD — App Service (docker-compose, credenciais ACR)

on:
  push: { branches: ["main"] }
  workflow_dispatch:

permissions:
  contents: read

env:
  ACR_NAME:        ${{ vars.ACR_NAME }}
  REGISTRY:        ${{ vars.ACR_NAME }}.azurecr.io
  RESOURCE_GROUP:  ${{ vars.AZ_RESOURCE_GROUP }}
  WEBAPP_NAME:     ${{ vars.AZ_WEBAPP_NAME }}
  COMPOSE_FILE:    docker-compose.yml
  IMAGE_TAG:       ${{ github.sha }}
  PRIVATE_SERVICES: "mqtt-kafka-bridge kafka-redis-consumer edge"

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      images: ${{ steps.images.outputs.list }}
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (service principal)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - uses: docker/setup-buildx-action@v3

      - name: Login no ACR
        run: az acr login -n "$ACR_NAME"

      - name: Build & Push (serviços privados)
        shell: bash
        run: |
          set -euo pipefail
          export REGISTRY="${{ env.REGISTRY }}"
          export REGISTRY_PREFIX="${REGISTRY}/"
          export IMAGE_TAG="${{ env.IMAGE_TAG }}"

          PRESENT=$(docker compose -f "${COMPOSE_FILE}" config --services)
          for s in $PRIVATE_SERVICES; do
            if echo "$PRESENT" | grep -qx "$s"; then
              echo ">> build/push: $s"
              docker compose -f "${COMPOSE_FILE}" build "$s"
              docker compose -f "${COMPOSE_FILE}" push  "$s"
            else
              echo ">> skip: $s (não está no compose)"
            fi
          done

      - name: Resolver imagens do compose (expand env)
        id: images
        shell: bash
        run: |
          set -euo pipefail
          export REGISTRY="${{ env.REGISTRY }}"
          export REGISTRY_PREFIX="${REGISTRY}/"
          export IMAGE_TAG="${{ env.IMAGE_TAG }}"

          docker compose -f "${COMPOSE_FILE}" config \
            | awk '/image:/ {print $2}' \
            | tr -d "\"'" > images.txt

          { echo 'list<<EOF'; cat images.txt; echo 'EOF'; } >> "$GITHUB_OUTPUT"

          echo "==== Imagens detectadas ===="
          cat images.txt

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (service principal)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Configurar App Settings (ACR + porta + warmup)
        shell: bash
        run: |
          set -euo pipefail
          az webapp config appsettings set -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --settings \
            DOCKER_REGISTRY_SERVER_URL="https://${{ env.REGISTRY }}" \
            DOCKER_REGISTRY_SERVER_USERNAME="${{ secrets.ACR_USERNAME }}" \
            DOCKER_REGISTRY_SERVER_PASSWORD="${{ secrets.ACR_PASSWORD }}" \
            WEBSITES_ENABLE_APP_SERVICE_STORAGE=true \
            WEBSITES_PORT=80 \
            WEBSITES_CONTAINER_START_TIME_LIMIT=240 >/dev/null

      # tenta via webapp update; se não rolar, aplica fallback com az resource update
      - name: Health Check e Always On (tentativa direta)
        shell: bash
        run: |
          set -euo pipefail
          az webapp update -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" \
            --set siteConfig.alwaysOn=true siteConfig.healthCheckPath="/healthz" || true

      - name: Health Check e Always On (fallback)
        shell: bash
        run: |
          set -euo pipefail
          az resource update -g "$RESOURCE_GROUP" \
            --resource-type "Microsoft.Web/sites/config" \
            -n "${WEBAPP_NAME}/web" \
            --set properties.alwaysOn=true properties.healthCheckPath="/healthz" || true
          az webapp show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" \
            --query "siteConfig.{alwaysOn:alwaysOn,healthCheckPath:healthCheckPath}"
      - name: Gerar compose final p/ Azure (expande variáveis)
        shell: bash
        run: |
          set -euo pipefail
          export REGISTRY="${{ env.REGISTRY }}"
          export IMAGE_TAG="${{ env.IMAGE_TAG }}"
          envsubst < docker-compose.azure.yml > docker-compose.final.yml
          echo "==== docker-compose.final.yml ===="
          cat docker-compose.final.yml

      - name: Deploy docker-compose ao App Service
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.WEBAPP_NAME }}
          configuration-file: ./docker-compose.final.yml  

      - name: Dump App Settings (porta e health)
        shell: bash
        run: |
          set -euo pipefail
          az webapp config appsettings list -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" \
            --query "[?name=='WEBSITES_PORT' || name=='WEBSITES_CONTAINER_START_TIME_LIMIT']" -o table
          az webapp show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" \
            --query "siteConfig.{alwaysOn:alwaysOn,healthCheckPath:healthCheckPath}" -o table

      - name: Mostrar container/compose aplicados
        shell: bash
        run: |
          set -euo pipefail
          az webapp config container show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" -o json

      - name: Debug HTTP (/healthz)
        shell: bash
        run: |
          set -euo pipefail
          HOST=$(az webapp show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --query defaultHostName -o tsv)
          echo "HEAD https://$HOST/healthz"
          curl -skI "https://$HOST/healthz" || true

      - name: Verificar saúde pós-deploy (/healthz)
        shell: bash
        run: |
          set -euo pipefail
          HOST=$(az webapp show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --query defaultHostName -o tsv)
          echo "Verificando https://$HOST/healthz"
          for i in {1..120}; do
            CODE=$(curl -sk -o /dev/null -w "%{http_code}" "https://$HOST/healthz" || true)
            if [[ "$CODE" =~ ^20[0-9]$ || "$CODE" =~ ^30[0-9]$ ]]; then
              echo "OK: $CODE"
              exit 0
            fi
            echo "Aguardando... (status=$CODE)"
            sleep 5
          done
          echo "Falha: healthcheck não respondeu 2xx/3xx."
          exit 1
