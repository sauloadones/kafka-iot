name: CI/CD — App Service (compose + Managed Identity + :live)

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: appservice-${{ vars.AZ_WEBAPP_NAME }}
  cancel-in-progress: true

env:
  # Azure / ACR
  ACR_NAME:        ${{ vars.ACR_NAME }}              # ex.: iotkafka
  REGISTRY:        ${{ vars.ACR_NAME }}.azurecr.io   # ex.: iotkafka.azurecr.io
  RESOURCE_GROUP:  ${{ vars.AZ_RESOURCE_GROUP }}     # ex.: iotstack-esus2-rg
  WEBAPP_NAME:     ${{ vars.AZ_WEBAPP_NAME }}        # ex.: iotkafka

  # Imutável por commit
  IMAGE_TAG:       ${{ github.sha }}

  # Compose único (no repo) — aponta para :live nas imagens privadas
  COMPOSE_FILE:    docker-compose.yml

  # Serviços privados hospedados no ACR (os que você builda)
  PRIVATE_SERVICES: "edge mqtt-kafka-bridge kafka-redis-consumer"

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.emit.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (Service Principal)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login no ACR
        run: az acr login -n "$ACR_NAME"

      - name: Build & Push (SHA) — serviços privados
        shell: bash
        run: |
          set -euo pipefail
          REG="${REGISTRY}"
          TAG="${IMAGE_TAG}"

          # ajuste estes caminhos para o layout real do seu repo:
          declare -A CTX=(
            ["edge"]="ops/edge"
            ["mqtt-kafka-bridge"]="python-bridge"
            ["kafka-redis-consumer"]="kafka-redis-consumer"
          )

          for s in ${PRIVATE_SERVICES}; do
            [ -d "${CTX[$s]}" ] || { echo "::error::Diretório '${CTX[$s]}' não existe"; exit 1; }
            echo ">> buildx $s  →  $REG/$s:$TAG  (ctx=${CTX[$s]})"
            docker buildx build --platform linux/amd64 \
              -t "$REG/$s:$TAG" \
              --push "${CTX[$s]}"
          done

      - name: Verificar tags no ACR (sanity)
        shell: bash
        run: |
          set -euo pipefail
          for r in ${PRIVATE_SERVICES}; do
            az acr repository show-tags -n "$ACR_NAME" --repository "$r" \
              --query "[?@=='${IMAGE_TAG}']" -o tsv | grep -q . || {
                echo "::error::Tag '${IMAGE_TAG}' ausente no repo '$r'"; exit 1; }
          done

      - name: Emitir tag para o job de deploy
        id: emit
        run: echo "tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login (Service Principal)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Ativar Managed Identity e conceder AcrPull
        shell: bash
        run: |
          set -euo pipefail
          az webapp identity assign -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" >/dev/null 2>&1 || true
          MI=$(az webapp show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --query identity.principalId -o tsv)
          ACR_ID=$(az acr show -n "$ACR_NAME" --query id -o tsv)

          az role assignment create \
            --assignee-object-id "$MI" \
            --assignee-principal-type ServicePrincipal \
            --role AcrPull \
            --scope "$ACR_ID" >/dev/null 2>&1 || true

          az webapp update -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" \
            --set siteConfig.acrUseManagedIdentityCreds=true >/dev/null

      - name: Remover DOCKER_* antigos (evita conflito com MI)
        shell: bash
        run: |
          az webapp config appsettings delete -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" \
            --setting-names DOCKER_REGISTRY_SERVER_URL DOCKER_REGISTRY_SERVER_USERNAME DOCKER_REGISTRY_SERVER_PASSWORD || true

      - name: Promover SHA -> :live (retag no ACR, atômico)
        shell: bash
        run: |
          set -euo pipefail
          for s in ${PRIVATE_SERVICES}; do
            echo ">> promote ${REGISTRY}/$s:${{ needs.build-and-push.outputs.tag }}  →  $s:live"
            az acr import -n "$ACR_NAME" \
              --source "${REGISTRY}/$s:${{ needs.build-and-push.outputs.tag }}" \
              -t "$s:live" --force
          done

      - name: App Settings essenciais (porta/health/AlwaysOn)
        shell: bash
        run: |
          az webapp config appsettings set -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --settings \
            WEBSITES_PORT=80 \
            WEBSITES_HEALTHCHECK_PATH=/healthz \
            WEBSITES_CONTAINER_START_TIME_LIMIT=600 \
            WEBSITES_ENABLE_APP_SERVICE_STORAGE=true >/dev/null

          az webapp update -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" \
            --set siteConfig.alwaysOn=true siteConfig.healthCheckPath="/healthz" >/dev/null

      - name: Aplicar compose único
        shell: bash
        run: |
          set -euo pipefail
          [ -f "${COMPOSE_FILE}" ] || { echo "::error::Arquivo não encontrado: ${COMPOSE_FILE}"; exit 1; }
          az webapp config container set -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" \
            --multicontainer-config-type COMPOSE \
            --multicontainer-config-file "${COMPOSE_FILE}"

      - name: Restart + health gate
        shell: bash
        run: |
          set -euo pipefail
          az webapp restart -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME"
          HOST=$(az webapp show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --query defaultHostName -o tsv)
          echo "Verificando https://${HOST}/healthz"
          for i in {1..120}; do
            CODE=$(curl -sk -o /dev/null -w "%{http_code}" "https://${HOST}/healthz" || true)
            if [[ "$CODE" =~ ^20[0-9]$ || "$CODE" =~ ^30[0-9]$ ]]; then
              echo "HEALTH OK ($CODE)"; exit 0
            fi
            echo "Aguardando... ($CODE)"; sleep 5
          done
          echo "::error::/healthz não respondeu 2xx/3xx no tempo limite."
          exit 1
