name: CI/CD — App Service (docker-compose, credenciais ACR)

on:
  push: { branches: [ "main" ] }
  workflow_dispatch:

permissions:
  contents: read

env:
  ACR_NAME:        ${{ vars.ACR_NAME }}
  REGISTRY:        ${{ vars.ACR_NAME }}.azurecr.io
  RESOURCE_GROUP:  ${{ vars.AZ_RESOURCE_GROUP }}
  WEBAPP_NAME:     ${{ vars.AZ_WEBAPP_NAME }}
  COMPOSE_FILE:    docker-compose.yml
  IMAGE_TAG:       ${{ github.sha }}
  PRIVATE_SERVICES: "mqtt-kafka-bridge kafka-redis-consumer edge"

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      images: ${{ steps.images.outputs.list }}
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (service principal secret)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - uses: docker/setup-buildx-action@v3

      - name: Login no ACR (para push)
        run: az acr login -n "$ACR_NAME"

      - name: Build & Push (somente serviços privados que existirem no compose)
        shell: bash
        run: |
          set -euo pipefail
          export REGISTRY="${{ env.REGISTRY }}"
          export IMAGE_TAG="${{ env.IMAGE_TAG }}"
          PRESENT=$(docker compose -f "${COMPOSE_FILE}" config --services)
          for s in $PRIVATE_SERVICES; do
            if echo "$PRESENT" | grep -qx "$s"; then
              echo ">> build/push: $s"
              docker compose -f "${COMPOSE_FILE}" build "$s"
              docker compose -f "${COMPOSE_FILE}" push  "$s"
            else
              echo ">> skip: $s (não está no compose)"
            fi
          done

      - name: Resolver imagens do compose (expand env)
        id: images
        shell: bash
        run: |
          set -euo pipefail
          export REGISTRY="${{ env.REGISTRY }}"
          export IMAGE_TAG="${{ env.IMAGE_TAG }}"
          docker compose -f "${COMPOSE_FILE}" config \
            | awk '/image:/ {print $2}' \
            | tr -d "\"'" > images.txt

          echo "list<<EOF" >> $GITHUB_OUTPUT
          cat images.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "==== Imagens detectadas ===="
          cat images.txt

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Azure login (service principal secret)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # App Settings só com credenciais do ACR (sem WEBSITES_PORT)
      - name: Configurar credenciais do registro no App Service
        shell: bash
        run: |
          set -euo pipefail
          az webapp config appsettings set -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --settings \
            DOCKER_REGISTRY_SERVER_URL="https://${REGISTRY}" \
            DOCKER_REGISTRY_SERVER_USERNAME="${{ secrets.ACR_USERNAME }}" \
            DOCKER_REGISTRY_SERVER_PASSWORD="${{ secrets.ACR_PASSWORD }}" \
            WEBSITES_ENABLE_APP_SERVICE_STORAGE=true >/dev/null

      # Health check e Always On no recurso (App Service vai tirar instância do LB se /healthz != 200)
      - name: Ajustar Health Check e Always On (compatível com qualquer CLI)
        shell: bash
        run: |
            set -euo pipefail
            # tenta via webapp update (se a CLI suportar)
            if ! az webapp update -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" \
                --set siteConfig.alwaysOn=true siteConfig.healthCheckPath="/healthz" >/dev/null 2>&1; then
              # fallback genérico
              az resource update -g "$RESOURCE_GROUP" \
                --resource-type "Microsoft.Web/sites/config" \
                -n "${WEBAPP_NAME}/web" \
                --set properties.alwaysOn=true properties.healthCheckPath="/healthz" >/dev/null
            fi
            # conferir
            az webapp show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" \
              --query "siteConfig.{alwaysOn:alwaysOn,healthCheckPath:healthCheckPath}"
      - name: Deploy docker-compose ao App Service
        uses: azure/webapps-deploy@v2
        with:
          app-name: ${{ env.WEBAPP_NAME }}
          configuration-file: ./${{ env.COMPOSE_FILE }}
          images: ${{ needs.build-and-push.outputs.images }}

      # HEAD pra ver código e cabeçalhos (descobre 401/302/503)
      - name: Debug HTTP (/healthz)
        shell: bash
        run: |
          set -euo pipefail
          HOST=$(az webapp show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --query defaultHostName -o tsv)
          echo "HEAD https://$HOST/healthz"
          curl -skI "https://$HOST/healthz" || true

      # Espera saudável (até 10 min, 5s entre tentativas)
      - name: Verificar saúde pós-deploy (/healthz)
        shell: bash
        run: |
          set -euo pipefail
          HOST=$(az webapp show -g "$RESOURCE_GROUP" -n "$WEBAPP_NAME" --query defaultHostName -o tsv)
          echo "Verificando https://$HOST/healthz"
          for i in {1..120}; do
            CODE=$(curl -sk -o /dev/null -w "%{http_code}" "https://$HOST/healthz" || true)
            if [ "$CODE" = "200" ]; then
              echo "OK: $CODE"
              exit 0
            fi
            echo "Aguardando... (status=$CODE)"
            sleep 5
          done
          echo "Falha: healthcheck não respondeu 200."
          exit 1